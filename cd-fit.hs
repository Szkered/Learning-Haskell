import Text.ParserCombinators.Parsec
import Data.Ix
import Data.List
import Data.Array
-- import Test.QuickCheck
import Control.Monad


parseInput =
  do dirs <- many dirAndSize
     eof::Parser ()
     return dirs

data Dir = Dir { dir_size::Integer, dir_name::String } deriving (Show, Eq)
data DirPack = DirPack { pack_size::Integer, dirs::[Dir] } deriving (Show, Eq)

dirAndSize =
  do size <- many1 digit
     spaces
     dir_name <- anyChar `manyTill` newline
     return (Dir (read size) dir_name)

main = do line <- getLine
          let maybeInt = readMaybe line :: Maybe Integer
          case maybeInt of
            Just n  -> do
              print $ "media size: " ++ show n
              input <- getContents
              putStrLn ("debug: input\n" ++ input)
              let dirs = case parse parseInput "stdin" input of
                              Left err -> error $ "Input:\n" ++ show input ++
                                                  "\nError:\n" ++ show err
                              Right result -> result
                  total_size = foldr (\d -> (+) (dir_size d)) 0 dirs
              putStrLn ("total size: " ++ show total_size)
              putStrLn "\nGreedy solution"
              print (greedy_pack dirs n)
              putStrLn "\nDynamic programming solution"
              print (dynamic_pack dirs n)
            Nothing -> putStrLn "error"

readMaybe s = case reads s of
                [(val, "")] -> Just val
                _           -> Nothing

-- media_size = 700*1024*1024      -- 700MB CD volume

-- simple greedy solution
greedy_pack in_dirs media_size = foldl (maybe_add_dir media_size) (DirPack 0 []) $ sortBy cmpSize in_dirs
  where cmpSize d1 d2 = compare (dir_size d2) (dir_size d1)
        maybe_add_dir m p d =
          let new_size = pack_size p + dir_size d
              new_dirs = d:(dirs p)
              in if new_size > m then p else DirPack new_size new_dirs


-- -- QuickCheck
-- instance Arbitrary Dir where
--          -- coarbitrary = undefined
--          arbitrary = liftM2 Dir gen_size gen_name
--            where gen_size = do s <- choose (10,1400)
--                                return (s*1024*1024)
--                  gen_name = do n <- choose (1,300)
--                                replicateM n (elements "fubar/")
-- prop_greedy_pack_is_fixpoint ds =
--                              let pack = greedy_pack ds m_size
--                              in pack_size pack == pack_size (greedy_pack (dirs pack) m_size )
-- prop_dynamic_pack_is_fixpoint ds =
--                              let pack = dynamic_pack ds m_size
--                              in pack_size pack == pack_size (dynamic_pack' (dirs pack) m_size )
-- prop_greedy_pack_is_no_better_than_dynamic_pack ds =
--   pack_size (greedy_pack ds m_size ) <= pack_size (dynamic_pack' ds m_size)

m_size = 100000      -- 700MB CD volume


-- Dynamic programming approach
precomputeDisksFor dirs =
  let precomp = map bestDisk [0..]
      bestDisk 0     = DirPack 0 [] -- best packed disk of size 0 is empty
      bestDisk limit =              -- recursive definition
        case [ DirPack (dir_size d + s) (d:ds)
               | d <- filter ( (inRange (1,limit)) . dir_size ) dirs  -- filter dir with size less than limit
                 , dir_size d > 0                                     -- safety check
                 , let (DirPack s ds) = precomp!!(fromInteger $ limit - dir_size d)
                 , d `notElem` ds
             ] of
             [] -> DirPack 0 []               -- negative case
             packs -> maximumBy cmpSize packs -- get the optimal pack
      cmpSize a b = compare (pack_size a) (pack_size b)
  in precomp

dynamic_pack dirs media_size = (precomputeDisksFor dirs)!!(fromInteger media_size)
-- the thing is.. if you're using array then probably something is wrong with your program..
-- the list generated by precomp will hog a large amount of memory space
-- let's take out the !! operator and rewrite this function

bestDisk 0 _        = DirPack 0 []
bestDisk _ []       = DirPack 0 []
bestDisk limit dirs =
  case [ DirPack (dir_size d + s) (d:ds)
         | let small_enough = filter ( (inRange (0,limit)) . dir_size ) dirs
           , d <- small_enough
           , dir_size d > 0
           , let (DirPack s ds) = bestDisk (limit - dir_size d) (delete d small_enough)
       ] of
       [] -> DirPack 0 []
       packs -> maximumBy cmpSize packs
  where cmpSize a b = compare (pack_size a) (pack_size b)

dynamic_pack' dirs media_size = bestDisk media_size dirs

-- main = quickCheck prop_dynamic_pack_is_fixpoint
-- TODO profiling doesn't work... cannot find parsec and quickcheck for some reason

-- MONADS! ------------------------------------
type Attribute = (Name, AttValue)
type AttValue = Either Value [Reference]
type Name = String
type Value = String
type Reference = String

simple_attrs = [ ( "xml:lang", Left "en" )
               , ( "xmlns", Left "jabber:client" )
               , ( "xmlns:stream", Left "http://etherx.jabber.org/streams" ) ]
complex_attrs = [ ( "xml:lang", Right ["lang"] )
                , ( "lang", Left "en" )
                , ( "xmlns", Right ["ns","subns"] )
                , ( "ns", Left "jabber" )
                , ( "subns", Left "client" )
                , ( "xmlns:stream", Left "http://etherx.jabber.org/streams" ) ]

lookupAttr :: Name -> [Attribute] -> Maybe Value -- type declaration are needed for type synonyms
lookupAttr nm attrs =
  case (lookup nm attrs) of
    Nothing   -> Nothing
    Just attv -> case attv of
                   Left val   -> Just val
                   Right refs ->
                         let vals = [ lookupAttr ref attrs | ref <- refs ]
                             wo_failures = filter (/= Nothing) vals
                             stripJust (Just v) = v
                             strings = map stripJust wo_failures
                         in case null strings of
                              True  -> Nothing
                              False -> Just (concat (intersperse ":" strings))
-- bloated codes... reason being we have too much (nested) control flow!
-- try/catch? Nope. Monad!


lookupAttr' :: Name -> [Attribute] -> Maybe Value -- type declaration are needed for type synonyms
lookupAttr' nm attrs = do
  attv <- lookup nm attrs       -- when we use <-, no need to check for Nothing anymore..
  case attv of
    Left val   -> Just val
    Right refs -> do vals <- sequence $ map (flip lookupAttr' attrs) refs
                     guard (not (null vals))
                     return (concat (intersperse ":" vals))


-- Let's reduce codes further! Use either to replace "case (Either a b) of"
-- either :: (a -> c) -> (b -> c) -> Either a b -> c
-- either provide a way to reconcile the two different types in Either monad to a thrid type c
lookupAttr'' :: Name -> [Attribute] -> Maybe Value -- type declaration are needed for type synonyms
lookupAttr'' nm attrs = do
  attv <- lookup nm attrs
  either Just (dereference attrs) attv
  where
     dereference attrs refs = do
                 vals <- sequence $ map (flip lookupAttr'' attrs) refs
                 guard (not (null vals))
                 return (concat (intersperse ":" vals))
